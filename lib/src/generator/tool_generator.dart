import 'dart:convert';

import 'package:analyzer/dart/element/element.dart';
import 'package:analyzer/dart/element/type.dart';
import 'package:build/build.dart';
import 'package:flutter_athropic_interface/flutter_athropic_interface.dart';
import 'package:source_gen/source_gen.dart';

const toolDefinitionChecker = TypeChecker.fromRuntime(ToolDefinition);
const toolFieldChecker = TypeChecker.fromRuntime(ToolField);

class ToolGenerator extends GeneratorForAnnotation<ToolDefinition> {
  @override
  String generateForAnnotatedElement(Element element, ConstantReader annotation, BuildStep buildStep) {
    if (element is! ClassElement) {
      throw InvalidGenerationSourceError('ToolDefinition can only be used on classes', element: element);
    }

    final toolName = annotation.read('name').stringValue;
    final toolDescription = _escapeString(annotation.read('description').stringValue);
    annotation.read('description').stringValue;

    final Map<String, dynamic> properties = {};
    final List<String> requiredFields = [];

    for (final field in element.fields) {
      if (field.isPrivate) continue;

      final fieldAnnotation = toolFieldChecker.firstAnnotationOf(field);
      if (fieldAnnotation == null) continue;

      if (fieldAnnotation.type.toString() == 'ToolField' || fieldAnnotation.type.toString() == 'ToolDefinition') {
        final DartType fieldType = field.type;

        final fieldReader = ConstantReader(fieldAnnotation);
        final description = _escapeString(fieldReader.read('description').stringValue);
        final isRequired = fieldReader.read('isRequired').boolValue;

        final fieldSchema = _schemaForDartType(field.type, description: description);

        List<String>? enumOptions;

        /// Se il tipo Ã¨ un enum, estrai tutti i valori
        if (fieldType.element is EnumElement) {
          final enumElement = fieldType.element as EnumElement;
          enumOptions = enumElement.fields.where((f) => f.isEnumConstant).map((f) => f.name).toList();
        }
        final example = fieldReader.read('example').isNull ? null : fieldReader.read('example').stringValue;

        final fieldSnakeCase = _camelToSnakeCase(field.name);

        // properties[fieldSnakeCase] = _buildPropertySchema(
        //   field.type.toString(),
        //   description,
        //   enumOptions,
        //   example,
        // );

        // if (description.isNotEmpty) {
        //   fieldSchema['description'] = description;
        // }
        if (example != null) {
          fieldSchema['example'] = example;
        }
        if (enumOptions != null && enumOptions.isNotEmpty) {
          fieldSchema['enum'] = enumOptions;
        }

        properties[fieldSnakeCase] = fieldSchema;

        if (isRequired) {
          requiredFields.add(fieldSnakeCase);
        }
      }
    }

    // Costruisci lo schema completo con type: object
    final schema = <String, dynamic>{
      'type': 'object',
      'properties': properties,
      if (requiredFields.isNotEmpty) 'isRequired': requiredFields,
    };

    // Genera il file .g.dart
    final className = element.name;
    final buffer = StringBuffer();

    final lowecasedClassName = _firstCharToLowerCase(className);

    buffer.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
    buffer.writeln('// This file is generated by tool_generator.dart');
    buffer.writeln('');
    buffer.writeln('part of \'${_camelToSnakeCase(className).toLowerCase()}.dart\';');
    buffer.writeln('');
    const encoder = JsonEncoder.withIndent('  ');
    final prettySchema = encoder.convert(schema);
    buffer.writeln('const String ${lowecasedClassName}ToolSchema = r\'\'\'');
    buffer.writeln(prettySchema);
    buffer.writeln('\'\'\';');
    buffer.writeln('');
    buffer.writeln('const String ${lowecasedClassName}ToolName = \'$toolName\';');
    buffer.writeln('');
    buffer.writeln('const String ${lowecasedClassName}ToolDescription = \'$toolDescription\';');
    buffer.writeln('');
    buffer.writeln('class ${className}Tool {');
    buffer.writeln('  static String get name => ${lowecasedClassName}ToolName;');
    buffer.writeln('  static String get description => ${lowecasedClassName}ToolDescription;');
    buffer.writeln('  static String get schema => ${lowecasedClassName}ToolSchema;');
    buffer.writeln('  static Map<String, dynamic> get tool => {"name": name, "description": description, "input_schema": schema};');
    buffer.writeln('  static Map<String, dynamic> get schemaMap => jsonDecode(schema);');
    buffer.writeln('}');

    return buffer.toString();
  }

  Map<String, dynamic> _schemaForDartType(DartType dartType, {String description = ''}) {
    // rimuove la nullability per la logica di tipo effettivo
    final nullableStripped = dartType.getDisplayString(withNullability: false);
    // inizializza schema vuoto
    final Map<String, dynamic> schema = {};

    // --- Enum ---
    final element = dartType.element;
    if (element is EnumElement) {
      // enum trattato come string con valori
      schema['type'] = 'string';
      if (description.isNotEmpty) {
        schema['description'] = description;
      }
      schema['enum'] = element.fields.where((f) => f.isEnumConstant).map((f) => f.name).toList();
      return schema;
    }

    // --- List / Iterable generics ---
    if (nullableStripped.startsWith('List<') || nullableStripped.startsWith('Iterable<') || nullableStripped.startsWith('Set<')) {
      // ottieni il type argument, se possibile
      if (dartType is InterfaceType && dartType.typeArguments.isNotEmpty) {
        schema['type'] = 'array';
        if (description.isNotEmpty) {
          schema['description'] = description;
        }
        schema['items'] = _schemaForDartType(dartType.typeArguments.first);
        return schema;
      } else {
        // generico array di stringhe se non risolto
        schema['type'] = 'array';
        if (description.isNotEmpty) {
          schema['description'] = description;
        }
        schema['items'] = {'type': 'string'};
        return schema;
      }
    }

    // --- Map ---
    if (nullableStripped.startsWith('Map<')) {
      // tratta map come object generico
      schema['type'] = 'object';
      if (description.isNotEmpty) {
        schema['description'] = description;
      }
      return schema;
    }

    // --- Primitive types ---
    if (nullableStripped == 'String') {
      schema['type'] = 'string';
      if (description.isNotEmpty) {
        schema['description'] = description;
      }
      return schema;
    }
    if (nullableStripped == 'int') {
      schema['type'] = 'integer';
      if (description.isNotEmpty) {
        schema['description'] = description;
      }
      return schema;
    }
    if (nullableStripped == 'double' || nullableStripped == 'num') {
      schema['type'] = 'number';
      if (description.isNotEmpty) {
        schema['description'] = description;
      }
      return schema;
    }
    if (nullableStripped == 'bool') {
      schema['type'] = 'boolean';
      if (description.isNotEmpty) {
        schema['description'] = description;
      }
      return schema;
    }

    // --- Class / Object (custom) ---
    if (element is ClassElement || element is InterfaceElement) {
      final classElement = element as ClassElement;
      // evita ricorsione su se stesso (protezione)
      schema['type'] = 'object';
      if (description.isNotEmpty) {
        schema['description'] = description;
      }

      final props = <String, dynamic>{};
      final required = <String>[];

      for (final f in classElement.fields) {
        // ignora campi privati, statici, synthetic (come .hashCode, .runtimeType)
        if (f.isPrivate || f.isStatic || f.isSynthetic) continue;

        // ottieni il nome snake_case come fai tu
        final fieldSnake = _camelToSnakeCase(f.name);

        // se il campo ha la tua annotazione ToolField usa la descrizione/isRequired
        // altrimenti non considerare description / required (ma puoi aggiungerle)
        String? description;
        bool isRequired = false;

        final ann = toolFieldChecker.firstAnnotationOf(f);
        if (ann != null && ann.type.toString() == 'ToolField') {
          final reader = ConstantReader(ann);
          if (!reader.read('description').isNull) {
            description = _escapeString(reader.read('description').stringValue);
          }
          if (!reader.read('isRequired').isNull) {
            isRequired = reader.read('isRequired').boolValue;
          }

          // genera schema ricorsivo per il tipo del campo
          final fieldSchema = _schemaForDartType(f.type, description: description ?? '');
          // if (description != null && description.isNotEmpty) {
          //   fieldSchema['description'] = description;
          // }

          props[fieldSnake] = fieldSchema;
          if (isRequired) required.add(fieldSnake);
        }
      }

      final classSchema = <String, dynamic>{
        'type': 'object',
        if (description.isNotEmpty) ...{
          'description': description,
        },
        'properties': props,
      };
      if (required.isNotEmpty) classSchema['required'] = required;
      return classSchema;
    }

    // default fallback: string
    schema['type'] = 'string';
    if (description.isNotEmpty) {
      schema['description'] = description;
    }
    return schema;
  }

  // static Map<String, dynamic> _buildPropertySchema(String type, String description, List<String>? enumValues, String? example) {
  //   final schema = <String, dynamic>{
  //     'description': description,
  //   };

  //   final jsonType = _mapDartTypeToJsonType(type);
  //   schema['type'] = jsonType;

  //   if (enumValues != null && enumValues.isNotEmpty) {
  //     schema['enum'] = enumValues;
  //   }

  //   if (example != null) {
  //     schema['example'] = example;
  //   }

  //   if (type.contains('List') && !type.contains('?')) {
  //     schema['minItems'] = 1;
  //   }

  //   return schema;
  // }

  // static String _mapDartTypeToJsonType(String dartType) {
  //   final baseType = dartType.replaceAll('?', '').trim();

  //   if (baseType.contains('String')) {
  //     return 'string';
  //   } else if (baseType.contains('int')) {
  //     return 'integer';
  //   } else if (baseType.contains('double') || baseType.contains('num')) {
  //     return 'number';
  //   } else if (baseType.contains('bool')) {
  //     return 'boolean';
  //   } else if (baseType.contains('List')) {
  //     return 'array';
  //   } else if (baseType.contains('Map')) {
  //     return 'object';
  //   }

  //   return 'string';
  // }

  static String _camelToSnakeCase(String camelCase) {
    final buffer = StringBuffer();
    for (int i = 0; i < camelCase.length; i++) {
      final char = camelCase[i];
      if (char == char.toUpperCase() && i > 0) {
        buffer.write('_');
        buffer.write(char.toLowerCase());
      } else {
        buffer.write(char);
      }
    }
    return buffer.toString();
  }
}

String _firstCharToLowerCase(String text) {
  if (text.isEmpty) return text;
  return text[0].toLowerCase() + text.substring(1);
}

String _escapeString(String str) {
  return str.replaceAll("\\", "\\\\").replaceAll("'", "\\'");
}

Builder toolGeneratorBuilder(BuilderOptions options) {
  return LibraryBuilder(ToolGenerator(), generatedExtension: '.tool.g.dart', header: '// GENERATED CODE - DO NOT MODIFY BY HAND\n');
}
